#!/usr/bin/env python

#
# Generated Flask routing module for SNAP microservice framework
#



from flask import Flask, request, Response
import snap



snap.setup(snap.app)
logger = snap.app.logger
xformer = snap.xformer


#_snap_transforms

{% for f in transform_functions %}
def {{ f }}(input_data, service_objects):
    raise snap.TransformNotImplementedException('{{f}}')
{% endfor %}

#_


#_snap_exception_handlers

xformer.register_error_code(snap.NullTransformInputDataException, snap.HTTP_BAD_REQUEST)
xformer.register_error_code(snap.MissingInputFieldException, snap.HTTP_BAD_REQUEST)
xformer.register_error_code(snap.TransformNotImplementedException, snap.HTTP_NOT_IMPLEMENTED)

#_



#_snap_data_shapes

{% for transform in transforms.values() %}
{{ transform.input_shape.name }} = core.InputShape()
{%- for field in transform.input_shape.fields %}
{{ transform.input_shape.name }}.add_field('{{ field.name }}', {{ field.is_required }})
{%- endfor %}
{% endfor %}

#_


#_snap_transform_loading

{%- for transform in transforms.values() %}
xformer.register_transform('{{transform.name}}', {{ transform.input_shape.name }}, {{ transform.function_name }}, {{ transform.output_type }})
{%- endfor %}

#_


{% for t in transforms.values() %}
@app.route('{{ t.path }}', methods=[{{ t.methods }}])
def {{t.name}}():
    try:
        {%- if t.methods == "'POST'" %}
        transform_status = xformer.transform('{{ t.name }}', request.json)
        {%- elif t.methods == "'GET'" or t.methods == "'DELETE'" %}        
        input_data = {}
        input_data.update(request.args)
        {%- for path_variable in t.path_variables %}        
        input_data['{{path_variable}}'] = {{ path_variable }}
        {%- endfor %}
        
        transform_status = xformer.transform('{{ t.name }}', convert_multidict(input_data))
        {%- else %}
        {%- endif %}        
        output_mimetype = xformer.target_mimetype_for_transform('{{ t.name }}')

        if transform_status.ok:
            return Response(transform_status.output_data, status=HTTP_OK, mimetype=output_mimetype)
        return Response(json.dumps(transform_status.user_data), status=transform_status.get_error_code() or HTTP_DEFAULT_ERRORCODE, mimetype=output_mimetype) 
    except Exception, err:
        logger.error("Exception thrown: ", exc_info=1)        
        raise err

{% endfor %}
